library(cem)
data(LL)
detach(package:cem)

# S=1 is fixed ratio matching

LL.mahal.satt <- makeFrontier(treatment="treated", dataset=LL, drop=c("re78", "treated"), QOI = 'SATT', metric = 'Mahal', S = 0)
LL.mahal.fsatt <- makeFrontier(treatment="treated", dataset=LL, drop=c("re78", "treated"), QOI = 'FSATT', metric = 'Mahal', S = 0)

LL.L1.satt <- makeFrontier(treatment="treated", dataset=LL, drop=c("re78", "treated"), QOI = 'SATT', metric = 'L1', S = 1)

LL.L1.fsatt <- makeFrontier(treatment="treated", dataset=LL, drop=c("re78", "treated"), QOI = 'FSATT', metric = 'L1', S = 1)
LL.L1.CEM <- makeFrontier(treatment="treated", dataset=LL, drop=c("re78", "treated"), QOI = 'FSATT', metric = 'L1', S = 0)

makeFrontier <- function(treatment, dataset, drop, mdist = NULL, QOI, metric, S){
    if(QOI == 'FSATT' & metric == 'Mahal' & S == 0){
        return(MahalFrontierFSATT(treatment="treated", dataset, drop, mdist))
    }
    if(QOI == 'SATT' & metric == 'Mahal' & S == 0){
        return(MahalFrontierSATT(treatment="treated", dataset, drop, mdist))
    }
    if(QOI == 'FSATT' & metric == 'L1' & S == 1){
        return(L1FrontierFSATT(treatment="treated", dataset, drop))
    }
    if(QOI == 'SATT' & metric == 'L1' & S == 1){
        return(L1FrontierSATT(treatment="treated", dataset, drop))
    }
    if(QOI == 'FSATT' & metric == 'L1' & S == 0){
        return(L1FrontierCEM(treatment="treated", dataset, drop))
    }
}

myMH <- function(Tnms, Cnms, inv.cov, dataset) {
 stopifnot(!is.null(dimnames(inv.cov)[[1]]), dim(inv.cov)[1] >
 1, all.equal(dimnames(inv.cov)[[1]], dimnames(inv.cov)[[2]]),
 all(dimnames(inv.cov)[[1]] %in% names(dataset)))
 covars <- dimnames(inv.cov)[[1]]
 xdiffs <- as.matrix(dataset[Tnms, covars])
 xdiffs <- xdiffs - as.matrix(dataset[Cnms, covars])
 rowSums((xdiffs %*% inv.cov) * xdiffs)
}

checkMatrix <- function(mdist, dataset, treatment){
    if(!is.matrix(mdist)){stop("the mdist provided is not a matrix")}
    ## are all the rownames of mdist treated units in the data?
    if(sum(rownames(mdist) %in% rownames(dataset[dataset[[treatment]]==1,])) != nrow(mdist)){stop("the rownames of mdist do not match the names of the treated units in the data.")}
    ## are all the treated units in the data listed as rows in mdist?
    if(sum(rownames(dataset[dataset[[treatment]]==1,]) %in% rownames(mdist)) != nrow(mdist)){stop("the rownames of mdist do not match the names of the treated units in the data.")}
    ## are all the colnames of mdist control units in the data?
    if(sum(colnames(mdist) %in% rownames(dataset[dataset[[treatment]]==0,])) != ncol(mdist)){stop("the colnames of mdist do not match the names of the control units in the data.")}  
    ## are all the control units in the data listed as columns in mdist?
    if(sum(rownames(dataset[dataset[[treatment]]==0,]) %in% colnames(mdist)) != ncol(mdist)){stop("the colnames of mdist do not match the names of the control units in the data.")}
}

calculateMdist <- function(dataset, treatment, matchVars){
    ## calculate the inverse covariance matrix
    icv <- solve(cov(dataset[, matchVars]))
    ## get the names of the treated
    trtnms <- row.names(dataset)[as.logical(dataset[[treatment]])]
    ## and the names of the control units
    ctlnms <- row.names(dataset)[!as.logical(dataset[[treatment]])]
    ## calculate the mahalanobis distances if not specified
    mdist <- outer(trtnms, ctlnms, FUN = myMH, inv.cov = icv, data = dataset)                                                                                  
    dimnames(mdist) <- list(trtnms, ctlnms)
    return(mdist)
}

frontierLoop <- function(dataset, treatment, distvec, minlist, mdist, strataList){
    ## Series of holders to store info about the frontier
    outholder <- c();dropped <- c();imbalance <- c(); matchedSampleSize <- c();wList <- list()
    
    ## Start a loop over the number of unique minimum distances
    for(i in 1:length(distvec)){
        ## We keep all units that have minimum distances <= this value
        currentThreshold <- distvec[i]
        ## This is the subset of minimum units that remain
        remainingMinimums <- minlist[minlist <= currentThreshold]
        ## we need the matched sample size
        matchedSampleSize <- c(matchedSampleSize, length(remainingMinimums))
        
        this.drop <- rownames(dataset)[!(rownames(dataset) %in% c(names(remainingMinimums), dropped))]
        dropped <- c(dropped, this.drop)
        
        ## calculate the Avg of all the minimum Mahalanobis discrepancies
        imbalance <- c(imbalance, mean(remainingMinimums))
        
        ## NEW -- calcalate a weights vector for this drop
        m_T <- table(dataset[[treatment]])[["1"]]
        m_C <- table(dataset[[treatment]])[["0"]]
        
        W <- rep(NA, nrow(dataset))
        names(W) <- rownames(dataset)
        ## fill in 1s for treated units that are still in
        W[(names(W) %in% rownames(mdist)) & (names(W) %in% names(remainingMinimums))] <- 1
        ## fill in 0s for all units that re out
        W[!(names(W) %in% names(remainingMinimums))] <- 0
        ## fill in weights for the rest
        cLeft <- W[(names(W) %in% colnames(mdist)) & (names(W) %in% names(remainingMinimums))]
        for(j in 1:length(cLeft)){
            sTab <- table(dataset[ names(strataList)[ strataList == strataList[names(cLeft[j])] ], ][[treatment]])
            m_T_s <- sTab["1"]
            m_C_s <- sTab["0"]
            W[names(cLeft[j])] <- (m_C/m_T)*(m_T_s/m_C_s)
        }
        wList[[i]] <- W 
    }
    return(list(balance = imbalance, drops = dropped, samplesize = matchedSampleSize, metric="Mahal", weights=wList))
}

makeStrata <- function(mdist, dataset, minlist){
    ##NEW -- try to calculate the parts for cemweights
    ## identify all obs that are mutually minimum to each other and call those strata
    ss <- list()
    for(i in 1:nrow(mdist)){
        ss[[length(ss)+1]] <- c(rownames(mdist)[i], names(which(mdist[i,] == minlist[rownames(mdist)[i]])))
    }
    for(i in 1:ncol(mdist)){
        ss[[length(ss)+1]] <- c(colnames(mdist)[i], names(which(mdist[,i] == minlist[colnames(mdist)[i]])))
    }
    ## Then combine all of them so that
    names(ss) <- as.character(1:length(ss))
    ss.names <- names(ss)
    for(i in 2:length(ss.names)){
        tmp <- ss[[ss.names[i]]]
        whichshare <- lapply(lapply(ss[1:(i-1)], function(x){tmp %in% x}), sum)
        ## if there is only one prior strata to combine with...
        if(sum(unlist(whichshare)) == 1){
            ss[[names(whichshare)[whichshare >0]]] <- unique(c(ss[[names(whichshare)[whichshare >0]]], tmp))
            ss[[ss.names[i]]] <- ""
        }
        ## if there is MORE THAN one prior strata to combine with...
        if(sum(unlist(whichshare)) > 1){
            ss[[ names(whichshare)[whichshare >0][1] ]] <- unique(c(unlist(ss[ names(whichshare)[whichshare >0] ]), tmp))
            ss[[ss.names[i]]] <- ""
            for(j in 2:sum(unlist(whichshare))){
                ss[[ names(whichshare)[whichshare >0][j] ]] <- ""
            }
        }
    }
    ## remove the empty holders
    ss <- ss[lapply(ss,function(x){sum(x=="")})==0]
    if( length(unlist(ss))!=nrow(dataset)){stop("The internal calculation of strata weights has messed up.")}
    ## then make an observation list with strata
    strataList <- rep(NA, nrow(dataset))
    names(strataList) <- rownames(dataset)
    for(i in 1:length(strataList)){
        strataList[i] <- names(ss)[unlist(lapply(ss, function(x){rownames(dataset)[i] %in% x}))]
    }
    return(strataList)
}

MahalFrontierFSATT <- function(treatment, dataset, drop, mdist = NULL){
## the vector of matching covariates
  matchVars <-  colnames(dataset)[!(colnames(dataset) %in% drop)]

  # Get distance matrix
  if(is.null(mdist)){mdist <- calculateMdist(dataset, treatment, matchVars)}

  # Check distance matrix
  checkMatrix(mdist, dataset, treatment)

  ## calculate the length to the closest unit in the opposite treatment condition
  ## for each unit.
  minlist <- c(apply(mdist,1,min), apply(mdist,2,min))
   
  strataList <- makeStrata(mdist, dataset, minlist)
  
  ## make a vector of all the unique minimum distances
  ## (this is the number of calculations we have to make)
  distvec <- rev(sort(unique(minlist)))

  return(frontierLoop(dataset, treatment, distvec, minlist, mdist, strataList))
}

MahalFrontierSATT <- function(treatment, dataset, drop, mdist){
    print("We presently can't calculate a Mahalanobis SATT frontier.")
}

######################
# END OF STUFF FOR MAHALANOBIS - BEGINNING OF L1
######################

getStrata <- function(treatment, dataset, drop, breaks=NULL){

  # Remove dropped observations
  dropped <- match(drop, colnames(dataset))
  if(length(dropped) > 0){
    dataset <- dataset[-dropped]
  }

  ## stuff borrowed from cem.main to add user defined breaks
  vnames <- colnames(dataset)
  nv <- dim(dataset)[2]
  mycut <- vector(nv, mode="list")
  names(mycut) <- vnames
  for (i in 1:nv) {	
    tmp <- reduceVar(dataset[[i]], breaks[[vnames[i]]])
    dataset[[i]] <- tmp$x
    mycut[[vnames[i]]] <- tmp$breaks
  }

  # Calculate strata
  strata <- stratify(dataset)
  return(list(strata=strata, mycut=mycut))
}

## the original reduce.var from cem
reduceVar <- function(x, breaks=NULL){
	if(is.numeric(x) | is.integer(x)){
	 if(is.null(breaks)){
	  breaks <- "sturges"
	  }
	 if(is.character(breaks)){
       breaks <- match.arg(tolower(breaks), c("sturges", 
                "fd", "scott", "ss"))
            breaks <- switch(breaks, sturges = nclass.Sturges(x), 
                 fd = nclass.FD(x), 
				 scott = nclass.scott(x), 
				 ss = nclass.ss(x),
                stop("unknown 'breaks' algorithm"))
        }
	 if(length(breaks) > 0){
		if(length(breaks)==1){
			rg <- range(x, na.rm=TRUE)
			breaks <- seq(rg[1],rg[2], length = breaks)
		}
		breaks <- unique(breaks)
		if(length(breaks)>1)
	     x <- cut(x, breaks=breaks, include.lowest = TRUE, labels = FALSE)
		else 	
		 x <- as.numeric(x) 
	 }
	} else {
	  x <- as.numeric(x) 
	}
	return(list(x=x, breaks=breaks)) 
}



# Takes a dataframe and returns a vector of length nrow(data), where
# element i is strata for observation i. 
stratify <- function (dataset){
  xx <- apply(dataset, 1, function(x) paste(x, collapse = "\r"))
  tab <- table(xx)
  st <- names(tab)
  strata <- match(xx,st)
  return(strata)
}

L1 <- function(strataholder){
  L1 <- 0
  num.treated <- 0
  num.control <- 0
  for(strat in strataholder){
    num.treated <- num.treated + sum((names(strat) == 1))
    num.control <- num.control + sum((names(strat) == 0))
  }
  for(strat in strataholder){
      strat.imb <- (sum(names(strat) == 1))/num.treated - (sum(names(strat) == 0))/num.control
      L1 <- L1 + abs(strat.imb)
  }
  return(L1 * .5)
}


L1FrontierCEM <- function(treatment, dataset, drop, breaks=NULL){
  require(cem)

  gs <- getStrata(treatment, dataset, drop, breaks=breaks)
  strata <- gs$strata
  mycut <- gs$mycut
  names(strata) <- dataset[,which(colnames(dataset) == treatment)]
  unique.strata <- unique(strata)
  strataholder <- list()
  for(i in 1:length(unique.strata)){
    strataholder[[i]] <- which(strata==unique.strata[i])
  }
  drops <- c()
  L1s <- c()
  samplesize <- c()
  wList <- list()

  ## calculate the L1 of the whole dataset
  imb <- imbalance(group=dataset[[treatment]], data=dataset, drop=drop, breaks = breaks)
  ## save the breaks that were randomly generated by the imbalance function
  if(is.null(breaks)){breaks <- imb$L1$breaks}
  L1s <- c(L1s, imb$L1$L1)
  samplesize <- c(samplesize, nrow(dataset))
  W <- rep(1,nrow(dataset))
  names(W) <- rownames(dataset)
  wList[[1]] <- W
  ## use cem to identify the singletons
  cem1 <- cem(treatment=treatment,data=dataset,cutpoints=breaks,L1.breaks=breaks,eval.imbalance=T, drop=drop)
  L1s <- c(L1s, cem1$imbalance$L1$L1)
  samplesize <- c(samplesize, sum(cem1$tab["Matched",]))
  W <- cem1$w
  names(W) <- rownames(dataset)
  wList[[2]] <- W
  
  #return(list(balance = L1s, drops = unname(drops), samplesize=samplesize, metric="L1-2", breaks=breaks))
  return(list(balance = L1s, samplesize=samplesize, metric="L1w", breaks=mycut, weights=wList))
}

L1FrontierSATT <- function(treatment, dataset, drop, breaks=NULL){
    gs <- getStrata(treatment, dataset, drop, breaks=breaks)
    strata <- gs$strata
    mycut <- gs$mycut
    names(strata) <- dataset[,which(colnames(dataset) == treatment)]
    unique.strata <- unique(strata)
    strataholder <- list()
    for(i in 1:length(unique.strata)){
        strataholder[[i]] <- which(strata==unique.strata[i])
    }
    drops <- c()
    L1s <- c()
    samplesize <- c()
    
    # Remove obs from imbalanced strata
    while(1){
    # get differences
        difference.vec <- c()
        
        for(s in 1:length(strataholder)){
            d <- sum(names(strataholder[[s]]) == '1') - sum(names(strataholder[[s]]) == '0')
            difference.vec <- c(difference.vec, d)
        }
        
        if(max(abs(difference.vec)) == 0){break}
        
        drop <- which(abs(difference.vec) == max(abs(difference.vec)))[1]
        sign <- sum(names(strataholder[[drop]]) == '1') - sum(names(strataholder[[drop]]) == '0')
        
        if(sign < 0){
            drop.obs <- which(names(strataholder[[drop]]) == 0)[1]
            dropped <- strataholder[[drop]][drop.obs]
    # drops <- c(drops, dropped)
            drops <- c(drops, rownames(dataset)[dropped])
            samplesize <- c(samplesize, nrow(dataset)-length(drops))
            strataholder[[drop]] <- strataholder[[drop]][-drop.obs]
        }
        L1s <- c(L1s, L1(strataholder))
        
    }
    return(list(balance = L1s, drops = unname(drops), samplesize=samplesize, metric="L1", breaks=mycut))
}

L1FrontierFSATT <- function(treatment, dataset, drop){}
 
